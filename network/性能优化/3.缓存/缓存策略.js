/*
协商缓存需要配合强缓存使用，没强缓存本地没缓存无从协商。
对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，当max-age过期了，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

1.强缓存：
    先根据本地缓存资源的 header 中(cahe-control,http1.1中的)的信息判断是否命中强缓存
    cache-control： 浏览器优先使用cache-control
        no-cache: 走协商缓存
        public(默认)：既可以给浏览器也可以给cdn代理服务器缓存
        private：只能给浏览器缓存
        no-store：强缓存协商缓存都不走，只准请求
        max-age = 3600,3600s内不需请求浏览器无需发出请求，直接使用本地缓存(服务端配置)
        s-maxage：只在cdn代理服务器中生效

    Expires：即服务器时间(绝对)。受限于本地时间，2种时间不一致会出现缓存失效，所以用的少

缓存max-age过期后走协商缓存

2.协商缓存：
    last-modified:  表示最后一次更新时间(只能精确到1S以内)
        下次浏览器请求资源时就发送if-modified-since字段。服务器用本地last-modified时间与if-modified-since时间比较，
        如果不一致则认为缓存已过期并返回新的资源给浏览器，如果时间一致则返回304状态码，让浏览器继续使用缓存。

    Etag：资源的实体标识（哈希字符串）
        与第一次请求返回给浏览器的if-none-match对应，当资源内容更新时，Etag会改变。
        服务器会判断Etag和if-none-match是否一致(类似指纹精准匹配)，如果不一致返回新资源，否则返回304。

last-modified缺点：
  1.某些服务端不能获取精确的修改时间
	2.如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。

缓存策略：
    首次进页面：先看浏览器中有没有缓存，没有就去请求服务器，服务器在响应头写缓存策略的头
    以后再进：判断缓存有没有过期，没有直接读缓存(强缓存)。过期就优先比对ETag再比对Last-Modified看有没过期
        没有返回304表示资源未更新，可使用本地的缓存，有的话就返回新数据

1.第一次请求服务器会返回last-Modified和Etag，再次请求该资源时会带上对应的if-modified-since、if-none-match


*/