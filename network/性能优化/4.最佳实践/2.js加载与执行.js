/*

1.js阻塞渲染，因为js是可以操作dom的，内嵌和外链js都是，页面渲染和用户交互完全被阻塞
  处理：将js尽量放到body底部，尽量减少对整个页面下载的影响。js是并行加载顺序执行的过程

2.http请求有额外性能开销，尽量把引用的多个js文件合并起来。压缩js

3.非核心代码异步加载：
  defer：可以放在任何位置，被解析到开始下载但会等HTML解析完成后才执行，有多个则按顺序执行
  async：同时进行HTML解析与js下载，但js下载完成后立刻停止HTML解析并执行js代码。有多个则谁快谁执行
  一般用defer：<script defer src="script.js"></script>

4.js性能:
    1）js会提高进程的CPU占用率，特别是写出内存泄漏、死循环的时候，浏览器关了就没事但要在node里出事就服务器宕机崩溃了（少用闭包）

5.尽量减少DOM访问：用JavaScript访问DOM元素是很慢的
    1）缓存共同的查找元素
    2）先“离线”更新节点，再把它们添到DOM树上。可使用 字符串 或者 documentFragment 一次性插入
    3）避免用JavaScript修复布局问题

6.事件代理：每绑定一个事件处理器是由代价的
  原理：事件逐层冒泡并能被父级元素捕获。DOM标准事件经历三个阶段：捕获(IE不支持) 到达目标 冒泡
  1)可能增重页面负担: 更多的标签或script代码
  2)可能增加了运行期的执行时间
  3)需要访问或修改的DOM元素越多，应用程序也就越慢，特别是事件绑定发生在onload时,
    这时候比较堵，事件绑定占用了处理时间，浏览器还需要跟踪每个事件处理器，会占更多内存

7.使用Service Workers

8.使用 tree shaking

9.代码分割：通过分包加载，减少首次加载所需时间
  Vendor splitting 库文件拆分，例如 React 或 lodash 单独打包成一个文件
  Entry point splitting 入口拆分，例如通过多页应用入口或者单页应用路由进行拆分
  Dynamic splitting 动态加载拆分，使用动态加载语法 import() ，实现模块按需加载

*/