/*

请求到了HTML文档后便开始解析:
1.HTML解析成DOM树，css解析成CSSOM树，DOM+CSSOM = renderTree(渲染树)就可以渲染了
2.css解析完毕才能进入生成渲染树环节(css解析阻塞render树渲染，不然可能render树渲染好css后解析好又要回流一次)

绘制过程：
    1.遍历渲染树开始布局，然后确定每个节点对象在页面上的确切大小与位置，输出是一个盒子模型
    2.布局完成后浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比，
        绘制完成后，用户就可以看到页面的最终呈现效果了。

优化策略：
1.把css放到head里，会阻塞渲染树的生成，防止二次渲染。给必需的css文件加rel="preload"，可以将请求优先级提到最高。

2.GUI线程和JS引擎线程是互斥的，js的加载和执行会阻塞渲染。js标签一般防止body标签最下面。
普通加载js：加载阻塞 & 执行阻塞
异步加载非核心js，加载都不阻塞：https://www.cnblogs.com/jiasm/p/7683930.html
    async：加载js，加载好就执行，执行阻塞。适合脚本之间独立不依赖的。
    defer：先加载，等文档渲染完毕后，在DOMContentLoaded事件调用前顺序执行，执行阻塞。适合脚本之间有依赖或者脚本会操作dom的。
*/