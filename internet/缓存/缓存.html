<!-- 
应用场景：
	1.大部分的场景都可以使用强缓存配合协商缓存解决
	2.对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，当max-age过期了，
		然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

强制缓存：
    cache-control： 浏览器优先使用cache-control
        no-cache:用于频繁变动的资源，并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
        public、private：用cdn代理服务器缓存就是public
        no-store：该资源不需要缓存,用于不需要缓存的文件
        max-age = 3600,3600s内不需请求浏览器无需发出请求，直接使用本地缓存(服务端配置)
        s-maxage：和max-age一个效果不过是作用于像cdn这种public的缓存设备

    Expires：即服务器时间(绝对)。受限于本地时间，2种时间不一致会出现缓存失效，所以用的少

缓存过期

协商缓存：
    last-modified:  表示最后一次更新时间(只能精确到1S以内)
        下次浏览器请求资源时就发送if-modified-since字段。服务器用本地last-modified时间与if-modified-since时间比较，
        如果不一致则认为缓存已过期并返回新的资源给浏览器，如果时间一致则返回304状态码，让浏览器继续使用缓存。

    Etag：资源的实体标识（哈希字符串）
        与第一次请求返回给浏览器的if-none-match对应，当资源内容更新时，Etag会改变。
        服务器会判断Etag和if-none-match是否一致(类似指纹精准匹配)，如果不一致返回新资源，否则返回304。

last-modified缺点：
    1.某些服务端不能获取精确的修改时间
	2.如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。

缓存策略：
    首次进页面：先看浏览器中有没有缓存，没有就去请求服务器，服务器在响应头写缓存策略的头
    以后再进：判断缓存有没有过期，没有直接读缓存(强缓存)。过期就优先比对ETag再比对Last-Modified看有没过期
        没有返回304直接读缓存，有的话就返回新数据

 -->