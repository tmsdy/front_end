<!-- 
死锁：如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的
    例子：有P1和P2两个进程，都需要A和B两个资源，现在P1持有A等待B资源，而P2持有B等待A资源，
        两个都等待另一个资源而不肯释放资源,就这样无限等待中，这就形成死锁

1.竞争不可抢占资源引起死锁（例子就是）

2.竞争可消耗资源引起死锁
    有p1，p2，p3三个进程，p1向p2发送消息并接受p3发送的消息，p2向p3发送消息并接受p2的消息，
    p3向p1发送消息并接受p2的消息，如果设置是先接到消息后发送消息，则所有的消息都不能发送，这就造成死锁

3.进程推进顺序不当引起死锁
    有进程p1，p2，都需要资源A，B，本来可以p1运行A -> p1运行B -> p2运行A -> p2运行B，但是顺序换了，
    p1运行A时p2运行B，容易发生第一种死锁。互相抢占资源。

死锁的必要条件：
    1.互斥条件
        某资源只能被一个进程使用，其他进程请求该资源时，只能等待，知道资源使用完毕后释放资源。
    2.请求和保持条件
        程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。
    3.不可抢占条件
        进程已获得的资源没有使用完，不能被抢占。
    4.循环等待条件
        必然存在一个循环链

预防死锁：
1.破坏请求和保持条件
协议1
所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件，即使有一种资源不能满足需求，
也不会给它分配正在空闲的资源，这样它就没有资源，就破坏了保持条件，从而预防死锁的发生。
协议2
允许一个进程只获得初期的资源就开始运行，然后再把运行完的资源释放出来。然后再请求新的资源。

2.破坏不可抢占条件
当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能被满足时，它必须释放已经保持的所有资源，以后需要时再重新申请。

3.破坏循环等待条件
对系统中的所有资源类型进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。假如进程请求到了一些序列号较高的资源，
然后有请求一个序列较低的资源时，必须先释放相同和更高序号的资源后才能申请低序号的资源。多个同类资源必须一起请求。


 -->