/*
* 1.V8引擎的内存机制
引擎会占用系统内存，对于像Java/Go这样的后端语言不限制内存使用，V8引擎限制内存使用一般为0.7GB～1.4GB
在前端来说大多数够用，但是对于node来说是不够用的。比如2G的文件, 那么它就无法将其全部读入内存且进行其他的操作.
    * 为什么设置内存上限？js是单线程的，垃圾回收耗费时间，以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要50ms 以上，做一次非增量式的垃圾回收甚至要 1s 以上.

* 2.js数据存储与回收
    * 1）栈中：js引擎会通过向下移动 ESP(记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文。
    * 2）堆中：V8堆内存分成新生代和老生代两个内存区
        新生代: 存放生存时间短的对象（临时变量、字符串之类）,只有16M～32M 的容量，副垃圾回收器来回收垃圾。
        老生代: 存放的生存时间久的对象,容量很大，主垃圾回收器来回收垃圾。

* 3.新生代中垃圾回收（Scavenge GC）
把新生代空间对半划分为对象区域(From)和空闲区域(To)。
存活对象列表：老生代对象每次指向一个新生对象的时候，记录下来；每次删除指向的时候，删除记录。
对象区域：新生对象诞生存这里，当对象区域快被写满时，触发 Scavenge GC。存活对象列表里存的From存活的对象复制到To空间按顺序从头放置，清空From空间(清除了垃圾)，然后From To 空间角色互换，开始下一轮循环。
为了防止新生区很快被占满，经过两次垃圾回收依然还存活的对象，会被移动到老生代区中。

* 4.老生代中的垃圾回收：标记清除法
先把所有变量都加上标记，再从根元素开始找引用的对象(递归遍历调用栈)，然后去掉环境中的变量及被环境中的变量引用的变量的标记，然后还有标记的变量将会被删除来回收内存(环境中的变量访问不到了)。
问题：清除垃圾后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。

整理内存：Mark-Compact标记压实算法，和标记清除过程差不多，不过最后是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块。
增量标记(V8优化)：将原本一口气完成的标记任务分为了很多小的部分去完成, 每完成一个小任务就停一会, 让js逻辑执行一会, 然后再继续执行下面的部分

* 注意
局部变量：函数执行完毕局部变量便没啥用了，因此垃圾收集器很容易做出判断并回收。
全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。

*/