/*
JS 中浮点数运算问题: https://juejin.im/post/5dab6dd7e51d457805049b18
* 1. 0.1+0.2为什么不等于0.3？
0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。

* 2.什么是BigInt?
BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

* 3.为什么需要BigInt?
在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？
这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的Number类型只能安全地表示-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)），任何超出此范围的整数值都可能失去精度。
console.log(999999999999999);  //=>10000000000000000
复制代码同时也会有一定的安全性问题:
9007199254740992 === 9007199254740993;    // → true 居然是true!
复制代码如何创建并使用BigInt？
要创建BigInt，只需要在数字末尾追加n即可。
console.log( 9007199254740995n );    // → 9007199254740995n
console.log( 9007199254740995 );     // → 9007199254740996
复制代码另一种创建BigInt的方法是用BigInt()构造函数、
BigInt("9007199254740995");    // → 9007199254740995n
复制代码简单使用如下:
10n + 20n;    // → 30n
10n - 20n;    // → -10n
+10n;         // → TypeError: Cannot convert a BigInt value to a number
-10n;         // → -10n
10n * 20n;    // → 200n
20n / 10n;    // → 2n
23n % 10n;    // → 3n
10n ** 3n;    // → 1000n

const x = 10n;
++x;          // → 11n
--x;          // → 9n
console.log(typeof x);   //"bigint"
*/
console.log(9999999999999999999999999999999999999999n)
console.log(1n + 2n)
console.log(1.255 * 100n)